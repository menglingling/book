import{_ as e,o as t,c as a,a as s}from"./app.20213b8a.js";const v=JSON.parse('{"title":"JS 中的 setTimeout和 setInterval","description":"","frontmatter":{"tags":["JavaScript","review"],"date":"2024-03-07-周四","cdate":"2024-03-07T17:35:06.000Z","mdate":"2024-03-07T17:35:06.000Z","status":"done","title":"JS 中的 setTimeout和 setInterval","hours":"1"},"headers":[{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"relativePath":"javascript/对象/JS 中的 setTimeout和 setInterval.md","lastUpdated":1715164291000}'),o={name:"javascript/对象/JS 中的 setTimeout和 setInterval.md"},i=s('<h1 id="js-中的-settimeout-和-setinterval" tabindex="-1">JS 中的 setTimeout 和 setInterval <a class="header-anchor" href="#js-中的-settimeout-和-setinterval" aria-hidden="true">#</a></h1><p>要取消函数的执行，我们应该调用  <code>clearInterval/clearTimeout</code>，并将  <code>setInterval/setTimeout</code>  返回的值作为入参传入。一定记住清楚定时器，否则垃圾回收程序不会回收外层函数。</p><p>嵌套的  <code>setTimeout</code>  比  <code>setInterval</code>  用起来更加灵活，允许我们更精确地设置两次执行之间的时间。</p><p>零延时调度  <code>setTimeout(func, 0)</code>（与  <code>setTimeout(func)</code>  相同）用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。</p><p>浏览器会将  <code>setTimeout</code>  或  <code>setInterval</code>  的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。</p><p>浏览器内的计时器可能由于许多原因而变慢：</p><ul><li>CPU 过载。</li><li>浏览器页签处于后台模式。</li><li>笔记本电脑用的是省电模式。</li></ul><p>所有这些因素，可能会将定时器的最小计时器分辨率（最小延迟）增加到 300ms 甚至 1000ms，具体以浏览器及其系统级别的设置为准。</p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-hidden="true">#</a></h2><ul><li>Javascript 现代教程</li></ul>',10),r=[i];function c(d,l,n,_,u,p){return t(),a("div",null,r)}const T=e(o,[["render",c]]);export{v as __pageData,T as default};
