import{_ as s,o as a,c as l,a as n}from"./app.20213b8a.js";const B=JSON.parse('{"title":"JS中的rest parameters 和 spread syntax","description":"","frontmatter":{"tags":["JavaScript"],"date":"2024-01-22-周一","cdate":"2024-01-22T17:33:16.000Z","mdate":"2024-01-23T12:33:16.000Z","status":"done","title":"JS中的rest parameters 和 spread syntax"},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"术语概念","slug":"术语概念","link":"#术语概念","children":[]},{"level":2,"title":"几个问答","slug":"几个问答","link":"#几个问答","children":[{"level":3,"title":"如何区别？","slug":"如何区别","link":"#如何区别","children":[]},{"level":3,"title":"扩展对象的顺序很重要，主要有两个原因。","slug":"扩展对象的顺序很重要-主要有两个原因。","link":"#扩展对象的顺序很重要-主要有两个原因。","children":[]},{"level":3,"title":"函数中原有的arguments的问题？","slug":"函数中原有的arguments的问题","link":"#函数中原有的arguments的问题","children":[]},{"level":3,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}]}],"relativePath":"javascript/JS中的剩余参数和扩展操作符.md","lastUpdated":1706520204000}'),e={name:"javascript/JS中的剩余参数和扩展操作符.md"},o=n(`<h1 id="js中的剩余参数和扩展操作符" tabindex="-1">JS中的剩余参数和扩展操作符 <a class="header-anchor" href="#js中的剩余参数和扩展操作符" aria-hidden="true">#</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><ul><li>ECMAScript 6 新增了剩余操作符和扩展操作符，这些新特性让集合类型之间相互操作、复制和修改变得异常方便。</li><li>ECMAScript 2018 将数组中的剩余操作符和扩展操作符也移植到了对象字面量。这极大地方便了对象合并和通过其他对象创建新对象。</li></ul><h2 id="术语概念" tabindex="-1">术语概念 <a class="header-anchor" href="#术语概念" aria-hidden="true">#</a></h2><ul><li>判断<code>...</code> 是剩余操作符还是扩展操作符，主要看当前<code>...</code>的功能作用或者使用场景是什么。剩余操作符和扩展操作符外观一样<code>...</code>，但是执行的基本是相反的操作。</li></ul><h2 id="几个问答" tabindex="-1">几个问答 <a class="header-anchor" href="#几个问答" aria-hidden="true">#</a></h2><h3 id="如何区别" tabindex="-1">如何区别？ <a class="header-anchor" href="#如何区别" aria-hidden="true">#</a></h3><ul><li>当收集的功能时，<strong>收集</strong>一个个单独数据元素变成一个新的集合对象。注意<code>...</code>放最后一个参数，有且只有一个。主要场景是： <ul><li>定义函数时，利用<code>···</code>收集多余的参数。</li><li>解构赋值时，利用<code>···</code>收集多余的参数。</li></ul></li><li>当扩展的功能时，<strong>展开</strong>一个集合对象变成一个个单独数据元素。没有位置和个数限制。主要场景是： <ul><li>调用函数时，参数直接传入数组，利用扩展操作符将传入的数组展开成单个参数，满足函数传参需要。</li><li>创建新数组，复制旧数组的所有元素到新创建的数组。</li><li>创建新对象，复制旧对象的所有自有可枚举属性到新的对象。</li></ul></li></ul><h3 id="扩展对象的顺序很重要-主要有两个原因。" tabindex="-1">扩展对象的顺序很重要，主要有两个原因。 <a class="header-anchor" href="#扩展对象的顺序很重要-主要有两个原因。" aria-hidden="true">#</a></h3><ul><li>对象跟踪插入顺序。从扩展对象复制的属性按照它们在对象字面量中列出的顺序插入。</li><li>对象会覆盖重名属性。在出现重名属性时，会使用后出现属性的值。 下面的例子演示了上述约定：</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> bar </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> foobar </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">c</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;">bar</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;">foo</span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(foobar)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// { c: 3, b: 2, a: 1 }</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> baz </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">c</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">4</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> foobarbaz </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{...</span><span style="color:#BABED8;">foo</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;">bar</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">c</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;">baz</span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(foobarbaz)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// { a: 1, b: 2, c: 4 }</span></span>
<span class="line"></span></code></pre></div><h3 id="函数中原有的arguments的问题" tabindex="-1">函数中原有的<code>arguments</code>的问题？ <a class="header-anchor" href="#函数中原有的arguments的问题" aria-hidden="true">#</a></h3><ul><li><code>arguments</code> 是一个类数组对象（likeArray）,可以迭代，但是不支持数组的方法，例如<code>arguments.map(...)</code></li><li>箭头函数没有<code>arguments</code>，没有<code>this</code></li></ul><h3 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-hidden="true">#</a></h3><ul><li><a href="https://javascript.info/rest-parameters-spread" target="_blank" rel="noreferrer">https://javascript.info/rest-parameters-spread</a></li><li>Javascript高级程序设计</li><li>MDN</li></ul>`,15),p=[o];function t(r,c,i,D,d,y){return a(),l("div",null,p)}const h=s(e,[["render",t]]);export{B as __pageData,h as default};
