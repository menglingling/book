import{_ as a,o as e,c as t,a as r}from"./app.20213b8a.js";const f=JSON.parse('{"title":"JS 中的装饰器模式和转发","description":"","frontmatter":{"tags":["JavaScript"],"date":"2024-03-08-周五","cdate":"2024-03-08T14:33:54.000Z","mdate":"2024-03-08T14:33:54.000Z","status":"done","title":"JS 中的装饰器模式和转发","hours":"1"},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":2,"title":"需要注意的问题","slug":"需要注意的问题","link":"#需要注意的问题","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"relativePath":"javascript/JS 中的装饰器的简单理解.md","lastUpdated":1715164291000}'),i={name:"javascript/JS 中的装饰器的简单理解.md"},l=r('<h1 id="js-中的装饰器相关问题" tabindex="-1">JS 中的装饰器相关问题 <a class="header-anchor" href="#js-中的装饰器相关问题" aria-hidden="true">#</a></h1><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-hidden="true">#</a></h2><p><strong>装饰器（decorator）</strong>：是一个函数，它接受另一个函数并改变它的行为。</p><p>将一个函数传给包装器函数，能加强原来函数的功能。使用包装器的好处是：</p><ul><li>不改变原来的函数，仅通过包装器就能加强原函数的功能</li><li>两个函数的逻辑是独立的，包装器可以重用</li><li>可以组合多个包装器实现复杂的代码功能</li></ul><h2 id="需要注意的问题" tabindex="-1">需要注意的问题 <a class="header-anchor" href="#需要注意的问题" aria-hidden="true">#</a></h2><p>当被包装的函数是对象的方法时，容易出现传入的函数 this 丢失的问题，需要在包装器函数中调用传入的函数时显示绑定 <code>this</code> 。</p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-hidden="true">#</a></h2><ul><li>Javascript 现代教程<a href="https://zh.javascript.info/call-apply-decorators" target="_blank" rel="noreferrer">https://zh.javascript.info/call-apply-decorators</a></li></ul>',9),s=[l];function d(c,n,o,h,_,p){return e(),t("div",null,s)}const S=a(i,[["render",d]]);export{f as __pageData,S as default};
