import{_ as e,o as a,c as s,a as l}from"./app.20213b8a.js";const b=JSON.parse('{"title":"JS中的复制对象","description":"","frontmatter":{"tags":["JavaScript"],"date":"2024-04-30-周二","cdate":"2024-05-08 16:32","mdate":"2024-05-08 16:32","status":"doing","title":"JS中的复制对象","hours":"1"},"headers":[{"level":2,"title":"拷贝","slug":"拷贝","link":"#拷贝","children":[]},{"level":2,"title":"shallow-copy","slug":"shallow-copy","link":"#shallow-copy","children":[{"level":3,"title":"Object.create","slug":"object-create","link":"#object-create","children":[]}]},{"level":2,"title":"deep-copy","slug":"deep-copy","link":"#deep-copy","children":[{"level":3,"title":"for in","slug":"for-in","link":"#for-in","children":[]}]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]},{"level":2,"title":"写在后面","slug":"写在后面","link":"#写在后面","children":[]}],"relativePath":"javascript/JS中的克隆对象.md","lastUpdated":1715164291000}'),t={name:"javascript/JS中的克隆对象.md"},n=l(`<h1 id="深拷贝浅拷贝的区别-实现一个深拷贝" tabindex="-1">深拷贝浅拷贝的区别，实现一个深拷贝 <a class="header-anchor" href="#深拷贝浅拷贝的区别-实现一个深拷贝" aria-hidden="true">#</a></h1><h2 id="拷贝" tabindex="-1">拷贝 <a class="header-anchor" href="#拷贝" aria-hidden="true">#</a></h2><p>解析：</p><ul><li>原始类型的变量大小固定，保存在栈内存中</li><li>从一个变量到另一个变量复制原始值会创建该值的第二个副本。</li><li>Object 类型的变量，存储在堆内存上，包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。</li><li>从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。</li><li>通过潜拷贝复制的对象引用的是同一个，修改值会相互影响。</li><li>通过深拷贝复制的对象是不同的副本，修改值不会相互影响。 javascript 中标准的内置对象复制操作都是潜拷贝： Object.create() Object.assign() Array.form() Array.prototype.concat() Array.prototype.slice() 实现深拷贝的方法:</li><li>JSON.stringify() JSON.parse()</li><li>递归循环对象属性一层一层的复制</li></ul><h2 id="shallow-copy" tabindex="-1">shallow-copy <a class="header-anchor" href="#shallow-copy" aria-hidden="true">#</a></h2><h3 id="object-create" tabindex="-1">Object.create <a class="header-anchor" href="#object-create" aria-hidden="true">#</a></h3><p>我们可以使用 Object.create 来实现比复制 for..in 循环中的属性更强大的对象克隆方式：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> clone </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#BABED8;">(</span></span>
<span class="line"><span style="color:#BABED8;">	Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPrototypeOf</span><span style="color:#BABED8;">(obj)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">	Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getOwnPropertyDescriptors</span><span style="color:#BABED8;">(obj)</span></span>
<span class="line"><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>此调用可以对 obj 进行真正准确地拷贝，包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 <code>[[Prototype]]</code>。</p><h2 id="deep-copy" tabindex="-1">deep-copy <a class="header-anchor" href="#deep-copy" aria-hidden="true">#</a></h2><h3 id="for-in" tabindex="-1">for in <a class="header-anchor" href="#for-in" aria-hidden="true">#</a></h3><p>简单讲，就是用 for in 去循环对象的属性，把属性一个个复写到一个新的对象上，如果遇到属性值还是对象，那么就做递归操作。</p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-hidden="true">#</a></h2><p>[javascript 高级程序设计]101</p><h2 id="写在后面" tabindex="-1">写在后面 <a class="header-anchor" href="#写在后面" aria-hidden="true">#</a></h2>`,15),r=[n];function o(c,i,p,d,h,y){return a(),s("div",null,r)}const u=e(t,[["render",o]]);export{b as __pageData,u as default};
