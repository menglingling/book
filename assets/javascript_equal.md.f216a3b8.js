import{_ as e,c as a,o as i,a as l}from"./app.639387d2.js";const f=JSON.parse('{"title":"== 和 === 的区别","description":"","frontmatter":{},"headers":[{"level":2,"title":"== 相等","slug":"相等","link":"#相等","children":[]},{"level":2,"title":"=== 严格相等","slug":"严格相等","link":"#严格相等","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]},{"level":2,"title":"写在后面","slug":"写在后面","link":"#写在后面","children":[]}],"relativePath":"javascript/equal.md"}'),t={name:"javascript/equal.md"},r=l('<h1 id="和-的区别" tabindex="-1">== 和 === 的区别 <a class="header-anchor" href="#和-的区别" aria-hidden="true">#</a></h1><h2 id="相等" tabindex="-1">== 相等 <a class="header-anchor" href="#相等" aria-hidden="true">#</a></h2><ul><li>仅比较值，不是同一类型的会隐式类型转换再比较</li><li>转换规则 <ul><li>null 和 undefined 相等</li><li>null 和 undefined 不能转换为其他类型的值再进行比较</li><li>NaN 不等于 NaN</li><li>两边同为原始类型，则布尔和字符串都会转换成数值类型再做比较</li><li>一边为原始类型，一边为对象，则对象转化为原始类型的值再比较</li><li>两边同为对象，则比较他们是否指向同一个对象</li></ul></li></ul><h2 id="严格相等" tabindex="-1">=== 严格相等 <a class="header-anchor" href="#严格相等" aria-hidden="true">#</a></h2><p>比较类型及值，不会做类型转换</p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-hidden="true">#</a></h2><p>[javascript 高级程序设计]</p><h2 id="写在后面" tabindex="-1">写在后面 <a class="header-anchor" href="#写在后面" aria-hidden="true">#</a></h2>',8),n=[r];function d(h,s,c,o,_,u){return i(),a("div",null,n)}const v=e(t,[["render",d]]);export{f as __pageData,v as default};
