import{_ as e,c as t,o as a,a as i}from"./app.47f178a3.js";const m=JSON.parse('{"title":"summary","description":"","frontmatter":{},"headers":[{"level":2,"title":"collection","slug":"collection","link":"#collection","children":[]},{"level":2,"title":"articale","slug":"articale","link":"#articale","children":[]}],"relativePath":"english/event_loop.md","lastUpdated":1672051340000}'),r={name:"english/event_loop.md"},o=i('<h1 id="summary" tabindex="-1">summary <a class="header-anchor" href="#summary" aria-hidden="true">#</a></h1><h2 id="collection" tabindex="-1">collection <a class="header-anchor" href="#collection" aria-hidden="true">#</a></h2><p>it will suspend its current operation 暂停</p><p>be allocated to the project 被分配到这个项目</p><p>is denoted as a function 被表示为一个函数;</p><p>is returning either implicitly or explicitly it will be popped off the stack. 隐式或显式</p><p>it keeps track of which function is currently executing.跟踪当前哪个函数在执行</p><p>Now we know from this that Javascript can execute one thing at a time but that’s not the case with the Browser. The Browser has its own set of APIs like setTimeout and XMLHttpRequests which are not specified in the Javascript runtime.</p><h2 id="articale" tabindex="-1">articale <a class="header-anchor" href="#articale" aria-hidden="true">#</a></h2><p><a href="https://www.freecodecamp.org/news/javascript-concurrency-model-and-event-loop/" target="_blank" rel="noreferrer">JavaScript Concurrency Model and Event Loop</a></p>',10),n=[o];function c(l,s,p,h,d,_){return a(),t("div",null,n)}const f=e(r,[["render",c]]);export{m as __pageData,f as default};
