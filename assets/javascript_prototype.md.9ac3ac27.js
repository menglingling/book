import{_ as e,c as t,o as a,a as i}from"./app.155f4677.js";const f=JSON.parse('{"title":"原型","description":"","frontmatter":{},"headers":[{"level":2,"title":"一些基本概念","slug":"一些基本概念","link":"#一些基本概念","children":[]},{"level":2,"title":"构造函数 实例 原型 之间的关系","slug":"构造函数-实例-原型-之间的关系","link":"#构造函数-实例-原型-之间的关系","children":[]}],"relativePath":"javascript/prototype.md","lastUpdated":1665750185000}'),r={name:"javascript/prototype.md"},l=i('<h1 id="原型" tabindex="-1">原型 <a class="header-anchor" href="#原型" aria-hidden="true">#</a></h1><h2 id="一些基本概念" tabindex="-1">一些基本概念 <a class="header-anchor" href="#一些基本概念" aria-hidden="true">#</a></h2><ul><li>javascript 的每一个对象都有 prototype 属性指向原型</li><li>原型之上还有原型</li><li>正常的原型链都会终止于 Object 的原型对象（即 Object.prototype ）</li><li>Object 原型的原型是 null</li><li>原型是 javascript 继承的主要方式</li></ul><h2 id="构造函数-实例-原型-之间的关系" tabindex="-1">构造函数 实例 原型 之间的关系 <a class="header-anchor" href="#构造函数-实例-原型-之间的关系" aria-hidden="true">#</a></h2><ul><li>构造函数的 <code>prototype</code> 属性指向原型</li><li>反之原型的 <code>constructor</code> 属性指回构造函数</li><li>构造函数可以 new 出实例</li><li>实例在浏览器中可通过<code>_proto_</code>属性访问原型,本身没有访问原型的标准方式</li></ul>',5),o=[l];function c(d,s,n,p,_,h){return a(),t("div",null,o)}const m=e(r,[["render",c]]);export{f as __pageData,m as default};
