import{_ as e,c as a,o as i,a as r}from"./app.28dd42b7.js";const l="/book/assets/s2022-11-16-15.49.51.8b332aa3.png",g=JSON.parse('{"title":"浏览器如何工作的","description":"","frontmatter":{},"headers":[{"level":2,"title":"导航","slug":"导航","link":"#导航","children":[{"level":3,"title":"DNS ，查询 IP 地址服务器","slug":"dns-查询-ip-地址服务器","link":"#dns-查询-ip-地址服务器","children":[]},{"level":3,"title":"TCP 握手，确认服务器与客户端的收发能力","slug":"tcp-握手-确认服务器与客户端的收发能力","link":"#tcp-握手-确认服务器与客户端的收发能力","children":[]},{"level":3,"title":"TLS 协商，HTTPS 建立安全的连接","slug":"tls-协商-https-建立安全的连接","link":"#tls-协商-https-建立安全的连接","children":[]}]},{"level":2,"title":"请求和响应","slug":"请求和响应","link":"#请求和响应","children":[{"level":3,"title":"TCP 慢启动/14KB 规则","slug":"tcp-慢启动-14kb-规则","link":"#tcp-慢启动-14kb-规则","children":[]}]},{"level":2,"title":"解析","slug":"解析","link":"#解析","children":[]},{"level":2,"title":"渲染","slug":"渲染","link":"#渲染","children":[{"level":3,"title":"构建 DOM 树","slug":"构建-dom-树","link":"#构建-dom-树","children":[]},{"level":3,"title":"构建 CSSOM 树","slug":"构建-cssom-树","link":"#构建-cssom-树","children":[]},{"level":3,"title":"组合 DOM 和 CSSOM 成渲染树","slug":"组合-dom-和-cssom-成渲染树","link":"#组合-dom-和-cssom-成渲染树","children":[]},{"level":3,"title":"布局","slug":"布局","link":"#布局","children":[]},{"level":3,"title":"绘画","slug":"绘画","link":"#绘画","children":[]}]},{"level":2,"title":"互动性","slug":"互动性","link":"#互动性","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"relativePath":"web/browser/browser.md","lastUpdated":1669340868000}'),t={name:"web/browser/browser.md"},d=r('<h1 id="浏览器如何工作的" tabindex="-1">浏览器如何工作的 <a class="header-anchor" href="#浏览器如何工作的" aria-hidden="true">#</a></h1><p>用户希望：应用页面快速加载，交互流畅。</p><p>Web 性能的两个主要问题是：</p><ul><li>理解与延迟有关的问题</li><li>大多数情况下浏览器是单线程的事实有关的问题。</li></ul><p>当用户请求网站或应用程序时，为了填充浏览器，有一系列步骤，包括 DNS 查找、TCP 握手和 SSL 协商. 然后浏览器解析接收到的内容，构建 DOM、CSSOM、可访问性和渲染树，最终渲染页面。</p><h2 id="导航" tabindex="-1">导航 <a class="header-anchor" href="#导航" aria-hidden="true">#</a></h2><p>导航是加载网页的第一步。每当用户通过在地址栏中输入 URL、单击链接、提交表单以及其他操作来请求页面时，它就会发生。</p><h3 id="dns-查询-ip-地址服务器" tabindex="-1">DNS ，查询 IP 地址服务器 <a class="header-anchor" href="#dns-查询-ip-地址服务器" aria-hidden="true">#</a></h3><p>导航到网页的第一步是找到该页面的资产所在的位置。</p><p>DNS ：域名解析系统，通过网址查找到对应的 IP 地址服务器。</p><p>基本划分：根域名，顶级域名（cn,com）,二级...</p><p>基本步骤：</p><ul><li>1 递归查询找浏览器缓存的</li><li>2 找操作系统 host</li><li>3 找本地域名服务器</li><li>4 迭代查询远程根域名服务器</li><li>5 查询顶级域名服务器</li><li>6 查询权威域名服务器</li><li>7 本地域名服务器缓存迭代查询的结果 IP 地址</li><li>8 操作系统缓存</li><li>9 浏览器缓存</li></ul><h3 id="tcp-握手-确认服务器与客户端的收发能力" tabindex="-1">TCP 握手，确认服务器与客户端的收发能力 <a class="header-anchor" href="#tcp-握手-确认服务器与客户端的收发能力" aria-hidden="true">#</a></h3><p>一旦知道 IP 地址，浏览器就会通过 TCP 三向握手建立与服务器的连接。</p><p>三次握手：通过三次握手，就能确定双方的接收和发送能力是正常的。 <img src="'+l+'" alt="img"></p><ul><li>第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常</li><li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li></ul><h3 id="tls-协商-https-建立安全的连接" tabindex="-1">TLS 协商，HTTPS 建立安全的连接 <a class="header-anchor" href="#tls-协商-https-建立安全的连接" aria-hidden="true">#</a></h3><p>通过 HTTPS 建立的安全连接,确定将使用哪种密码来加密通信、验证服务器并在开始实际数据传输之前建立安全连接。</p><p>在实际发送内容请求之前，这需要与服务器进行三次以上的往返。</p><h2 id="请求和响应" tabindex="-1">请求和响应 <a class="header-anchor" href="#请求和响应" aria-hidden="true">#</a></h2><p>一旦我们与 Web 服务器建立了连接，浏览器就会代表用户发送一个初始 HTTPGET 请求，对于网站来说，这通常是一个 HTML 文件。</p><p>一旦服务器收到请求，它会回复相关的响应头和 HTML 的内容。</p><h3 id="tcp-慢启动-14kb-规则" tabindex="-1">TCP 慢启动/14KB 规则 <a class="header-anchor" href="#tcp-慢启动-14kb-规则" aria-hidden="true">#</a></h3><p>第一个响应数据包将是 14KB。这是 TCP 慢启动的一部分，一种平衡网络连接速度的算法。慢启动逐渐增加传输的数据量，直到可以确定网络的最大带宽。</p><p>在 TCP 慢启动中，在收到初始数据包后，服务器将下一个数据包的大小加倍到 28KB 左右。后续数据包的大小会增加，直到达到预定阈值或出现拥塞。</p><p>如果您听说过初始页面加载的 14KB 规则，TCP 慢启动是初始响应为 14KB 的原因，也是 Web 性能优化要求针对初始 14KB 响应进行集中优化的原因。TCP 慢启动逐渐建立适合网络能力的传输速度以避免拥塞。</p><h2 id="解析" tabindex="-1">解析 <a class="header-anchor" href="#解析" aria-hidden="true">#</a></h2><p>一旦浏览器接收到第一块数据，它就可以开始解析接收到的信息。</p><p>解析是浏览器将其通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，渲染器使用这些数据将页面绘制到屏幕上。</p><p>即使请求页面的 HTML 大于初始的 14KB 数据包，浏览器也会开始解析并尝试根据其拥有的数据呈现体验。这就是为什么在前 14 KB 中包含浏览器开始呈现页面所需的所有内容或至少包含页面模板（首次呈现所需的 CSS 和 HTML）对于 Web 性能优化很重要。但在将任何内容呈现到屏幕之前，必须解析 HTML、CSS 和 JavaScript。</p><h2 id="渲染" tabindex="-1">渲染 <a class="header-anchor" href="#渲染" aria-hidden="true">#</a></h2><h3 id="构建-dom-树" tabindex="-1">构建 DOM 树 <a class="header-anchor" href="#构建-dom-树" aria-hidden="true">#</a></h3><p>html 元素是文档树的第一个标记和根节点。DOM 节点的数量越多，构建 DOM 树所需的时间就越长。</p><p>当解析器找到非阻塞资源（例如图像）时，浏览器将请求这些资源并继续解析。</p><p>当遇到 CSS 文件时，解析可以继续。</p><p>当遇到 script 文件时，尤其是那些没有 async/defer 属性的标签会阻止渲染，并暂停 HTML 的解析。</p><p>尽管浏览器的预加载扫描器加快了这个过程，但过多的脚本仍然是一个重要的瓶颈。</p><h3 id="构建-cssom-树" tabindex="-1">构建 CSSOM 树 <a class="header-anchor" href="#构建-cssom-树" aria-hidden="true">#</a></h3><p>关键渲染路径的第二步是处理 CSS 和构建 CSSOM 树。</p><p>构建 CSSOM 非常非常快。</p><p>在当前的开发人员工具中不会以独特的颜色显示。相反，开发人员工具中的“重新计算样式”显示了解析 CSS、构建 CSSOM 树和递归计算计算样式所花费的总时间。</p><p>在 Web 性能优化方面，有更容易实现的成果，因为创建 CSSOM 的总时间通常少于一次 DNS 查找所需的时间。</p><h3 id="组合-dom-和-cssom-成渲染树" tabindex="-1">组合 DOM 和 CSSOM 成渲染树 <a class="header-anchor" href="#组合-dom-和-cssom-成渲染树" aria-hidden="true">#</a></h3><p>关键渲染路径的第三步是将 DOM 和 CSSOM 组合成渲染树。计算样式树或渲染树的构造从 DOM 树的根开始，遍历每个可见节点。</p><h3 id="布局" tabindex="-1">布局 <a class="header-anchor" href="#布局" aria-hidden="true">#</a></h3><p>关键渲染路径中的第四步是在渲染树上布局。</p><p>布局是<strong>初始</strong>确定渲染树中所有节点的<strong>大小和位置</strong>的过程。</p><p>重排是<strong>后续</strong>确定页面部分或整个文档的<strong>大小和位置</strong>的过程。</p><p>一旦构建了渲染树，布局就开始了。渲染树识别显示哪些节点（即使不可见）及其计算样式，但不识别每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器从渲染树的根开始并遍历它。</p><p>布局一般从 body 开始，布局所有 body 的后代尺寸，每个元素的盒模型属性，为不知道尺寸的替换元素提供占位符空间，例如 image。</p><p>假设初始布局发生在返回图像之前。由于我们没有声明图像的大小，因此一旦知道图像大小就会进行重排（回流）。</p><h3 id="绘画" tabindex="-1">绘画 <a class="header-anchor" href="#绘画" aria-hidden="true">#</a></h3><p>关键渲染路径的最后一步是将各个节点用像素绘制到屏幕上。</p><p>绘画涉及将元素的每个视觉部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换元素（如按钮和图像）。浏览器需要非常快速地完成这项工作。</p><p>为了确保流畅的滚动和动画，所有占用主线程的东西，包括计算样式，以及回流和绘制，都必须让浏览器在 16.67 毫秒内完成。</p><p>在 2048 X 1536 下，iPad 有超过 3,145,000 个像素要绘制到屏幕上。这是很多像素，必须非常快速地绘制。为了确保重绘可以比初始绘制更快地完成，屏幕上的绘图通常被分解成几层。如果发生这种情况，则需要进行合成。</p><p>绘画可以将布局树中的元素分解成层。</p><p>将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重绘性能。</p><p>有一些特定的属性和元素可以实例化一个层，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，以及任何具有 CSS 属性 opacity3D transform、will-change 和其他一些元素的元素。这些节点将连同它们的后代一起绘制到它们自己的层上，除非后代出于上述一个（或多个）原因需要它自己的层。</p><p>层确实可以提高性能，但在内存管理方面代价高昂，因此不应将其过度用作 Web 性能优化策略的一部分。</p><h4 id="合成" tabindex="-1">合成 <a class="header-anchor" href="#合成" aria-hidden="true">#</a></h4><p>当文档的各个部分绘制在不同的层中并相互重叠时，合成是必要的，以确保它们以正确的顺序绘制到屏幕上并且内容被正确呈现。</p><p>随着页面继续加载资产，可能会发生回流（回想一下我们迟到的示例图像）。回流会引发重绘和重新合成。如果我们定义了图像的大小，就不需要回流，只有需要重绘的图层才会被重绘，并在必要时进行合成。但是我们没有包括图像大小！从服务器获取图像后，渲染过程返回到布局步骤并从那里重新开始。</p><h2 id="互动性" tabindex="-1">互动性 <a class="header-anchor" href="#互动性" aria-hidden="true">#</a></h2><p>主线程完成页面绘制后，您会认为我们“一切就绪”。不一定是这样。如果加载包括正确延迟的 JavaScript，并且仅在 onload 事件触发后执行，则主线程可能很忙，无法用于滚动、触摸和其他交互。</p><p>交互时间(TTI) 衡量的是从导致 DNS 查找和 SSL 连接的第一个请求到页面交互时所用的时间——交互是在第一次内容绘制之后页面响应时的时间点 50 毫秒内的用户交互。如果主线程忙于解析、编译和执行 JavaScript，则它不可用，因此无法及时（小于 50 毫秒）响应用户交互。</p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-hidden="true">#</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work" target="_blank" rel="noreferrer">MDN 浏览器如何工作的</a><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path" target="_blank" rel="noreferrer">MDN 浏览器渲染</a></p>',69),p=[d];function h(s,n,c,o,S,b){return i(),a("div",null,p)}const m=e(t,[["render",h]]);export{g as __pageData,m as default};
